<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TailQ链表队列</title>
    <link href="/2024/03/24/TailQ%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97/"/>
    <url>/2024/03/24/TailQ%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="0、零零零"><a href="#0、零零零" class="headerlink" title="0、零零零"></a>0、零零零</h1><p>最近在看iperf3的源码，发现使用了TailQ作为维护不同协议结构的链表。想到之前在工作中使用tailQ还引发了一些bug，觉得有必要好好整理一下tailQ的相关细节。</p><p>TailQ是一个双向链表，虽然双向链表是一个比较基础的数据结构，但是TailQ的设计还是十分精巧的，既有相当灵活和泛用的使用场景，又不依赖于linux惯用的container_of宏获取节点数据，这个设计思路值得好好琢磨琢磨。</p><h1 id="1、TailQ结构"><a href="#1、TailQ结构" class="headerlink" title="1、TailQ结构"></a>1、TailQ结构</h1><p><img src="https://picgozz.oss-cn-beijing.aliyuncs.com/img/202403241501455.svg" alt="tailq_struct"></p><p>TailQ由一个list head和若干list node两种结构组成：</p><h3 id="TAILQ-HEAD"><a href="#TAILQ-HEAD" class="headerlink" title="TAILQ_HEAD"></a>TAILQ_HEAD</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TAILQ_HEAD(name, type)                                    \</span><br><span class="hljs-meta">struct name &#123;                                                     \</span><br><span class="hljs-meta">struct type *tqh_first; <span class="hljs-comment">/* first element */</span>                     \</span><br><span class="hljs-meta">struct type **tqh_last; <span class="hljs-comment">/* addr of last next element */</span>         \</span><br><span class="hljs-meta">&#125;                                                              </span><br></code></pre></td></tr></table></figure><p>宏展开后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">name</span> </span><br><span class="hljs-class">&#123;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">tqh_first</span>;</span> <br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> **<span class="hljs-title">tqh_last</span>;</span>  <br>&#125; <br></code></pre></td></tr></table></figure><p>该宏定义的是TailQ的list head，链表头中有两个type指针。在使用的时候，name是这个tailQ头结构的名字，而type则是链表节点的类型名。尤其要注意的是，thq_last与tqh_first不同，它是一个二重指针，从这里就能看出tailQ和最常见的双向链表不一样，分析使用接口的时候才能更深切的体会其奥妙。</p><h3 id="TAILQ-ENTRY"><a href="#TAILQ-ENTRY" class="headerlink" title="TAILQ_ENTRY"></a>TAILQ_ENTRY</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TAILQ_ENTRY(type)                                         \</span><br><span class="hljs-meta">struct &#123;                                                          \</span><br><span class="hljs-meta">struct type *tqe_next;  <span class="hljs-comment">/* next element */</span>                      \</span><br><span class="hljs-meta">struct type **tqe_prev; <span class="hljs-comment">/* address of previous next element */</span>  \</span><br><span class="hljs-meta">&#125;  </span><br></code></pre></td></tr></table></figure><p>该宏展开后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> *<span class="hljs-title">tqe_next</span>;</span> <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">type</span> **<span class="hljs-title">tqe_prev</span>;</span>  <br>&#125; <br></code></pre></td></tr></table></figure><p>该宏定义的是tailQ节点的结构，和tailQ头的定义对比，可以发现head节点和node节点的结构除了变量名之外是大差不差的。所以head和node节点在经过类型转换后，都可以操作tqh_last指针或tqe_next指针，其效果是一样的，在接口中经常有这两种结构的复用操作。</p><p>定义了结构以后，链表还需要初始化，我们看下tailQ的初始化接口。</p><h3 id="TAILQ-INIT"><a href="#TAILQ-INIT" class="headerlink" title="TAILQ_INIT"></a>TAILQ_INIT</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TAILQ_INIT(head) do &#123;                                     \</span><br><span class="hljs-meta">TAILQ_FIRST((head)) = NULL;                                     \</span><br><span class="hljs-meta">(head)-&gt;tqh_last = &amp;TAILQ_FIRST((head));                        \</span><br><span class="hljs-meta">&#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TAILQ_FIRST(head)       ((head)-&gt;tqh_first)</span><br></code></pre></td></tr></table></figure><p>该宏展开后：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">do</span> &#123; <br>  <span class="hljs-function"><span class="hljs-params">(((head))-&gt;tqh_first)</span> = <span class="hljs-params">((<span class="hljs-literal">void</span>*)<span class="hljs-number">0</span>)</span>; </span><br><span class="hljs-function">  <span class="hljs-params">(head)</span>-&gt;</span>tqh_last = &amp;<span class="hljs-function"><span class="hljs-params">(((&amp;testp-&gt;xbind_addrs))-&gt;tqh_first)</span>; </span><br><span class="hljs-function">&#125; <span class="hljs-title">while</span> <span class="hljs-params">(<span class="hljs-number">0</span>)</span></span><br></code></pre></td></tr></table></figure><p>这个操作很好理解，将队列头的first指针置为NULL，last指针指向first域（这就是二级指针的原因，其指向了一个指针），初始化完的链表就如图中所示的空列表状态。</p><p>那列表中如果有其他节点是什么样的状态呢？看图中下面的列表，其有一个列表头和3个节点。我们发现数据不是在tailQ节点结构中的，而是tailQ节点被数据的结构体包含着，这样做的原因是增强数据结构的灵活性和泛用性，linux的大量数据结构都是这么定义的。但tailQ的定义方式与linux的一些数据结构定义还有所不同，没有与数据完全解耦，而是通过给用户开放节点定义的接口，让用户自己把需要的数据包含到节点中。关于这一点想详细了解的同学，可以去翻看linux container_of宏的相关定义。</p><p>根据示意图我们可以总结出tailQ结构的几个特点：</p><ul><li>链表头的tqh_first指针指向列表中第一个节点；链表头的tqh_last指针指向列表最后一个节点的tqe_next域；</li><li>节点的tqe_next指针指向下一个节点；节点的tqe_prev指针指向下一个节点的tqe_next域。</li></ul><p>对比一下，链表头和链表节点的结构基本就是一模一样的，其next指针都指向下一个节点，prev指针都指向上一个节点的next域，而链表头则分别连接链表的第一个节点和最后一个节点。我们再分析一下，可以发现一些隐藏的特点：</p><ul><li>一个节点的tqe_prev节点解引用，就是一个指向自己这个节点的一级指针</li></ul><p>这个特点是tailQ很多接口操作的基础，也是其设计最精妙的所在，理解了这个操作就可以很快的明白其他接口的原理。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第一章</title>
    <link href="/2024/03/08/%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2024/03/08/%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p><strong>第一篇博文，就贴一张图吧！</strong></p><p><img src="https://picgozz.oss-cn-beijing.aliyuncs.com/img/202403082312389.jpeg" alt="mofang"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
